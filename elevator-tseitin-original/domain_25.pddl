(define (domain elevators)
(:constants
  pass_r pass_u pass_x pass_n pass_w pass_g pass_k pass_y pass_d pass_l a b c e f h i j m o p q s t v)
(:predicates
  (passenger ?p)
  (boarded ?p)
  (served ?p)
  (floor ?p)
  (origin ?p ?f)
  (destin ?p ?f)
  (liftat ?f)
  (next ?f1 ?f2)
  (DATALOG_PASSENGER ?x0)
  (DATALOG_FLOOR ?x0)
  (DATALOG_INCONSISTENT)
  (DATALOG_QUERY0 ?x0 ?x1)
  (AUX0 ?y0)
  (AUX1 ?y0 ?y1 ?y2)
  (AUX2 ?x))
(:derived (DATALOG_PASSENGER ?x0)
          (passenger ?x0))
(:derived (DATALOG_PASSENGER ?x0)
          (exists (?y0) (destin ?x0 ?y0)))
(:derived (DATALOG_FLOOR ?x0)
          (floor ?x0))
(:derived (DATALOG_FLOOR ?x0)
          (exists (?y0) (destin ?y0 ?x0)))
(:derived (DATALOG_INCONSISTENT)
          (exists (?y0) (AUX0 ?y0)))
(:derived (DATALOG_INCONSISTENT)
          (exists (?y0 ?y1 ?y2) (AUX1 ?y0 ?y1 ?y2)))
(:derived (DATALOG_QUERY0 ?x0 ?x1)
          (and (boarded ?x1) (destin ?x1 ?x0)))
(:derived (DATALOG_PASSENGER ?x0)
          (exists (?y0) (origin ?x0 ?y0)))
(:derived (DATALOG_FLOOR ?x0)
          (liftat ?x0))
(:derived (DATALOG_FLOOR ?x0)
          (exists (?y0) (origin ?y0 ?x0)))
(:derived (DATALOG_PASSENGER ?x0)
          (served ?x0))
(:derived (DATALOG_PASSENGER ?x0)
          (boarded ?x0))
(:derived (AUX0 ?y0)
          (and (DATALOG_FLOOR ?y0) (DATALOG_PASSENGER ?y0)))
(:derived (AUX1 ?y0 ?y1 ?y2)
          (and (next ?y0 ?y1) (next ?y0 ?y2) (not (= ?y1 ?y2))))
(:derived (AUX2 ?x)
          (or (served ?x) (not (DATALOG_PASSENGER ?x))))
(:action stop
  :parameters (?p ?f)
  :precondition (and (DATALOG_PASSENGER ?p) (liftat ?f) (not (DATALOG_INCONSISTENT)))
  :effect (and (when (and (origin ?p ?f) (not (boarded ?p)) (not (served ?p))) (boarded ?p)) (when (DATALOG_QUERY0 ?f ?p) (and (served ?p) (not (boarded ?p))))))
(:action moveUp
  :parameters (?f1 ?f2)
  :precondition (and (liftat ?f1) (next ?f1 ?f2) (not (DATALOG_INCONSISTENT)))
  :effect (when (and (liftat ?f1) (not (= ?f1 ?f2))) (and (liftat ?f2) (not (liftat ?f1)))))
(:action moveDown
  :parameters (?f1 ?f2)
  :precondition (and (liftat ?f1) (next ?f2 ?f1) (not (DATALOG_INCONSISTENT)))
  :effect (when (and (liftat ?f1) (not (= ?f1 ?f2))) (and (liftat ?f2) (not (liftat ?f1)))))
)