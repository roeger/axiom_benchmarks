(define (domain BTcat)
(:requirements :adl :derived-predicates)
(:constants
  aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br)
(:predicates
  (cat ?x)
  (bomb ?x)
  (contains ?x ?y)
  (package ?x)
  (disarmed ?x)
  (DATALOG_QUERY0 ?x0 ?x1)
  (DATALOG_INCONSISTENT)
  (DATALOG_PACKAGE ?x0)
  (AUX0 ?y0)
  (AUX1 ?y2 ?y0 ?y1)
  (AUX2 ?x))
(:derived (DATALOG_QUERY0 ?x0 ?x1)
          (and (bomb ?x1) (contains ?x0 ?x1)))
(:derived (DATALOG_INCONSISTENT)
          (or (exists (?y0 ?y1 ?y2) (AUX1 ?y2 ?y0 ?y1)) (exists (?y0) (AUX0 ?y0))))
(:derived (DATALOG_PACKAGE ?x0)
          (or (exists (?y0) (contains ?x0 ?y0)) (package ?x0)))
(:derived (AUX0 ?y0)
          (and (bomb ?y0) (cat ?y0)))
(:derived (AUX1 ?y2 ?y0 ?y1)
          (and (contains ?y0 ?y1) (contains ?y0 ?y2) (not (= ?y1 ?y2))))
(:derived (AUX2 ?x)
          (or (disarmed ?x) (not (DATALOG_PACKAGE ?x))))
(:action dunk
  :parameters (?x ?y)
  :precondition (and (DATALOG_PACKAGE ?x) (not (DATALOG_INCONSISTENT)))
  :effect (when (DATALOG_QUERY0 ?x ?y) (and (disarmed ?x))))
(:action let_the_cats_out
  :parameters (?x ?y)
  :precondition (and (DATALOG_PACKAGE ?x) (not (DATALOG_INCONSISTENT)))
  :effect (when (contains ?x ?y) (and (not (contains ?x ?y)) (cat ?y))))
)
